#!/usr/bin/env python3
"""
Collective Memory - Quick Console v2.0
Hafƒ±za tabanlƒ± g√∂rev ve hata y√∂netim sistemi
"""

import sys
import sqlite3
import datetime
import hashlib
import os
from pathlib import Path


class QuickConsole:
    def __init__(self):
        self.db_path = "comprehensive_system.db"
        self.session_start = datetime.datetime.now()
        self.command_history = []
        self.load_memory_rules()
        self.initialize_database()

    def load_memory_rules(self):
        """Hafƒ±za kurallarƒ±nƒ± y√ºkle"""
        self.memory_rules = {
            "auto_mark_completed": True,
            "track_completion_time": True,
            "save_solutions": True,
            "categorize_tasks": True,
            "priority_system": True,
            "document_tracking": True,  # Yeni: Dok√ºman izleme
        }

    def initialize_database(self):
        """Veritabanƒ± tablolarƒ±nƒ± olu≈ütur"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Processed documents tablosunu olu≈ütur
        cursor.execute(
            """
            CREATE TABLE IF NOT EXISTS processed_documents (
                id TEXT PRIMARY KEY,
                file_path TEXT NOT NULL,
                file_name TEXT NOT NULL,
                file_hash TEXT NOT NULL,
                file_size INTEGER NOT NULL,
                processing_type TEXT NOT NULL,
                processing_date DATETIME NOT NULL,
                last_modified DATETIME NOT NULL,
                status TEXT DEFAULT 'processed',
                notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """
        )

        # Index olu≈ütur
        cursor.execute(
            """
            CREATE INDEX IF NOT EXISTS idx_processed_documents_hash 
            ON processed_documents(file_hash)
        """
        )

        cursor.execute(
            """
            CREATE INDEX IF NOT EXISTS idx_processed_documents_path 
            ON processed_documents(file_path)
        """
        )

        conn.commit()
        conn.close()

    def calculate_file_hash(self, file_path):
        """Dosya hash'ini hesapla"""
        if not os.path.exists(file_path):
            return None

        hash_md5 = hashlib.md5()
        try:
            with open(file_path, "rb") as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hash_md5.update(chunk)
            return hash_md5.hexdigest()
        except Exception as e:
            print(f"‚ùå Hash hesaplama hatasƒ±: {e}")
            return None

    def is_document_processed(self, file_path):
        """Dok√ºmanƒ±n daha √∂nce i≈ülenip i≈ülenmediƒüini kontrol et"""
        if not os.path.exists(file_path):
            return False

        current_hash = self.calculate_file_hash(file_path)
        if not current_hash:
            return False

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT file_hash, last_modified FROM processed_documents 
            WHERE file_path = ? AND status = 'processed'
        """,
            (file_path,),
        )

        result = cursor.fetchone()
        conn.close()

        if not result:
            return False

        stored_hash, last_modified = result

        # Hash aynƒ± mƒ± kontrol et
        if stored_hash == current_hash:
            # Dosya deƒüi≈üiklik tarihi kontrol et
            file_mtime = datetime.datetime.fromtimestamp(os.path.getmtime(file_path))
            stored_mtime = datetime.datetime.fromisoformat(last_modified)

            if file_mtime <= stored_mtime:
                return True

        return False

    def mark_document_processed(self, file_path, processing_type="indexed", notes=None):
        """Dok√ºmanƒ± i≈ülenmi≈ü olarak i≈üaretle"""
        if not os.path.exists(file_path):
            print(f"‚ùå Dosya bulunamadƒ±: {file_path}")
            return False

        file_hash = self.calculate_file_hash(file_path)
        if not file_hash:
            return False

        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        file_stats = os.stat(file_path)
        file_name = os.path.basename(file_path)
        file_size = file_stats.st_size
        last_modified = datetime.datetime.fromtimestamp(file_stats.st_mtime)
        current_time = datetime.datetime.now()

        doc_id = f"DOC_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}_{file_name}"

        # Mevcut kaydƒ± kontrol et
        cursor.execute(
            """
            SELECT id FROM processed_documents WHERE file_path = ?
        """,
            (file_path,),
        )

        existing = cursor.fetchone()

        if existing:
            # G√ºncelle
            cursor.execute(
                """
                UPDATE processed_documents 
                SET file_hash = ?, file_size = ?, last_modified = ?, 
                    processing_type = ?, notes = ?, updated_at = ?
                WHERE file_path = ?
            """,
                (
                    file_hash,
                    file_size,
                    last_modified.isoformat(),
                    processing_type,
                    notes,
                    current_time.isoformat(),
                    file_path,
                ),
            )
        else:
            # Yeni kayƒ±t
            cursor.execute(
                """
                INSERT INTO processed_documents 
                (id, file_path, file_name, file_hash, file_size, processing_type, 
                 processing_date, last_modified, notes)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    doc_id,
                    file_path,
                    file_name,
                    file_hash,
                    file_size,
                    processing_type,
                    current_time.isoformat(),
                    last_modified.isoformat(),
                    notes,
                ),
            )

        conn.commit()
        conn.close()

        print(f"‚úÖ Dok√ºman i≈ülendi: {file_name}")
        return True

    def list_processed_documents(self, limit=10):
        """ƒ∞≈ülenmi≈ü dok√ºmanlarƒ± listele"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT file_name, file_path, processing_type, processing_date, 
                   file_size, status
            FROM processed_documents 
            ORDER BY processing_date DESC 
            LIMIT ?
        """,
            (limit,),
        )

        documents = cursor.fetchall()
        conn.close()

        if not documents:
            print("üìÑ ƒ∞≈ülenmi≈ü dok√ºman bulunamadƒ±")
            return

        print(f"üìÑ ƒ∞≈ülenmi≈ü Dok√ºmanlar (Son {limit}):")
        print("-" * 80)

        for doc in documents:
            file_name, file_path, proc_type, proc_date, file_size, status = doc

            # Dosya boyutunu formatla
            if file_size > 1024 * 1024:
                size_str = f"{file_size / (1024*1024):.1f} MB"
            elif file_size > 1024:
                size_str = f"{file_size / 1024:.1f} KB"
            else:
                size_str = f"{file_size} B"

            print(f"üìÑ {file_name}")
            print(f"   üìÅ {file_path}")
            print(f"   üîÑ {proc_type} | üìÖ {proc_date} | üìä {size_str}")
            print(f"   ‚úÖ {status}")
            print()

    def get_document_stats(self):
        """Dok√ºman istatistiklerini al"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT 
                COUNT(*) as total_docs,
                COUNT(CASE WHEN status = 'processed' THEN 1 END) as processed_docs,
                SUM(file_size) as total_size,
                processing_type
            FROM processed_documents
            GROUP BY processing_type
        """
        )

        results = cursor.fetchall()

        cursor.execute(
            """
            SELECT COUNT(*) as total_docs, SUM(file_size) as total_size
            FROM processed_documents
        """
        )

        total_stats = cursor.fetchone()
        conn.close()

        return {
            "total_docs": total_stats[0] if total_stats else 0,
            "total_size": total_stats[1] if total_stats and total_stats[1] else 0,
            "by_type": results,
        }

    def check_unprocessed_documents(self, directory_path):
        """Dizindeki i≈ülenmemi≈ü dok√ºmanlarƒ± kontrol et"""
        if not os.path.exists(directory_path):
            print(f"‚ùå Dizin bulunamadƒ±: {directory_path}")
            return

        unprocessed = []
        supported_extensions = [".md", ".txt", ".py", ".js", ".json", ".yaml", ".yml"]

        for root, dirs, files in os.walk(directory_path):
            for file in files:
                file_path = os.path.join(root, file)
                file_ext = os.path.splitext(file)[1].lower()

                if file_ext in supported_extensions:
                    if not self.is_document_processed(file_path):
                        unprocessed.append(file_path)

        if unprocessed:
            print(f"üìÑ ƒ∞≈ülenmemi≈ü dok√ºmanlar ({len(unprocessed)}):")
            for doc in unprocessed[:10]:  # ƒ∞lk 10'u g√∂ster
                print(f"  üìÑ {doc}")

            if len(unprocessed) > 10:
                print(f"  ... ve {len(unprocessed) - 10} tane daha")
        else:
            print("‚úÖ T√ºm dok√ºmanlar i≈ülenmi≈ü")

        return unprocessed

    def get_task_stats(self):
        """G√∂rev istatistiklerini al"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute("SELECT COUNT(*) FROM tasks WHERE status = 'completed'")
        completed_tasks = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM tasks WHERE status = 'pending'")
        pending_tasks = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM tasks WHERE status = 'in_progress'")
        in_progress_tasks = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM errors WHERE status = 'resolved'")
        resolved_errors = cursor.fetchone()[0]

        cursor.execute("SELECT COUNT(*) FROM errors WHERE status = 'active'")
        active_errors = cursor.fetchone()[0]

        conn.close()

        return {
            "completed_tasks": completed_tasks,
            "pending_tasks": pending_tasks,
            "in_progress_tasks": in_progress_tasks,
            "resolved_errors": resolved_errors,
            "active_errors": active_errors,
        }

    def complete_task(self, task_search, solution=None):
        """G√∂revi tamamla"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        current_time = datetime.datetime.now().isoformat()

        # ID ile ara
        cursor.execute(
            """
            UPDATE tasks 
            SET status = 'completed', 
                updated_at = ?
            WHERE id = ?
        """,
            (current_time, task_search),
        )

        # Eƒüer ID ile bulunamazsa ba≈ülƒ±kta ara
        if cursor.rowcount == 0:
            cursor.execute(
                """
                UPDATE tasks 
                SET status = 'completed', 
                    updated_at = ?
                WHERE title LIKE ?
            """,
                (current_time, f"%{task_search}%"),
            )

        if cursor.rowcount > 0:
            conn.commit()
            print(f"‚úÖ G√∂rev tamamlandƒ±: {task_search}")
            if solution:
                print(f"üí° √á√∂z√ºm: {solution}")
        else:
            print(f"‚ùå G√∂rev bulunamadƒ±: {task_search}")

        conn.close()

    def resolve_error(self, error_search, solution=None):
        """Hatayƒ± √ß√∂z√ºmle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        current_time = datetime.datetime.now().isoformat()

        # ID ile ara
        cursor.execute(
            """
            UPDATE errors 
            SET status = 'resolved', 
                updated_at = ?,
                solution = ?
            WHERE id = ?
        """,
            (current_time, solution, error_search),
        )

        # Eƒüer ID ile bulunamazsa ba≈ülƒ±kta ara
        if cursor.rowcount == 0:
            cursor.execute(
                """
                UPDATE errors 
                SET status = 'resolved', 
                    updated_at = ?,
                    solution = ?
                WHERE title LIKE ?
            """,
                (current_time, solution, f"%{error_search}%"),
            )

        if cursor.rowcount > 0:
            conn.commit()
            print(f"‚úÖ Hata √ß√∂z√ºld√º: {error_search}")
            if solution:
                print(f"üí° √á√∂z√ºm: {solution}")
        else:
            print(f"‚ùå Hata bulunamadƒ±: {error_search}")

        conn.close()

    def add_task(
        self, title, description=None, priority="medium", project="collective-memory"
    ):
        """Yeni g√∂rev ekle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        task_id = f"TASK_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
        current_time = datetime.datetime.now().isoformat()

        cursor.execute(
            """
            INSERT INTO tasks (id, title, description, priority, status, 
                              created_at, updated_at, project)
            VALUES (?, ?, ?, ?, 'pending', ?, ?, ?)
        """,
            (
                task_id,
                title,
                description,
                priority,
                current_time,
                current_time,
                project,
            ),
        )

        conn.commit()
        conn.close()

        print(f"üìù Yeni g√∂rev eklendi: {task_id}")
        print(f"üìã Ba≈ülƒ±k: {title}")

    def add_error(
        self, title, description=None, severity="medium", error_type="general"
    ):
        """Yeni hata ekle"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        error_id = f"ERROR_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}"
        current_time = datetime.datetime.now().isoformat()

        cursor.execute(
            """
            INSERT INTO errors (id, title, description, severity, error_type, 
                               status, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, 'active', ?, ?)
        """,
            (
                error_id,
                title,
                description,
                severity,
                error_type,
                current_time,
                current_time,
            ),
        )

        conn.commit()
        conn.close()

        print(f"üî¥ Yeni hata eklendi: {error_id}")
        print(f"üìã Ba≈ülƒ±k: {title}")

    def list_tasks(self, status=None, limit=10):
        """G√∂revleri listele"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        if status:
            cursor.execute(
                """
                SELECT id, title, status, priority, created_at, updated_at
                FROM tasks WHERE status = ? ORDER BY created_at DESC LIMIT ?
            """,
                (status, limit),
            )
        else:
            cursor.execute(
                """
                SELECT id, title, status, priority, created_at, updated_at
                FROM tasks ORDER BY created_at DESC LIMIT ?
            """,
                (limit,),
            )

        tasks = cursor.fetchall()
        conn.close()

        if not tasks:
            print("üìã G√∂rev bulunamadƒ±.")
            return

        print(f"üìã G√ñREVLER ({len(tasks)}):")
        print("=" * 60)

        for task in tasks:
            task_id, title, status, priority, created_at, updated_at = task
            status_icon = (
                "‚úÖ"
                if status == "completed"
                else "‚è≥" if status == "in_progress" else "üìã"
            )

            print(f"{status_icon} {task_id}")
            print(f"   üìù {title}")
            print(f"   üìä Status: {status} | Priority: {priority}")
            print(f"   üìÖ Created: {created_at}")
            if updated_at != created_at:
                print(f"   üîÑ Updated: {updated_at}")
            print()

    def list_errors(self, status=None, limit=10):
        """Hatalarƒ± listele"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        if status:
            cursor.execute(
                """
                SELECT id, title, status, severity, created_at, updated_at, solution
                FROM errors WHERE status = ? ORDER BY created_at DESC LIMIT ?
            """,
                (status, limit),
            )
        else:
            cursor.execute(
                """
                SELECT id, title, status, severity, created_at, updated_at, solution
                FROM errors ORDER BY created_at DESC LIMIT ?
            """,
                (limit,),
            )

        errors = cursor.fetchall()
        conn.close()

        if not errors:
            print("üî¥ Hata bulunamadƒ±.")
            return

        print(f"üî¥ HATALAR ({len(errors)}):")
        print("=" * 60)

        for error in errors:
            error_id, title, status, severity, created_at, updated_at, solution = error
            status_icon = "‚úÖ" if status == "resolved" else "üî¥"

            print(f"{status_icon} {error_id}")
            print(f"   üìù {title}")
            print(f"   üìä Status: {status} | Severity: {severity}")
            print(f"   üìÖ Created: {created_at}")
            if updated_at != created_at:
                print(f"   üîÑ Updated: {updated_at}")
            if solution:
                print(f"   üí° √á√∂z√ºm: {solution}")
            print()

    def status(self):
        """Sistem durumunu g√∂ster"""
        stats = self.get_task_stats()
        uptime = datetime.datetime.now() - self.session_start

        print("üìä Sƒ∞STEM DURUMU")
        print("=" * 50)
        print(f"‚úÖ Tamamlanan G√∂revler: {stats['completed_tasks']}")
        print(f"‚è≥ Bekleyen G√∂revler: {stats['pending_tasks']}")
        print(f"üîÑ Devam Eden G√∂revler: {stats['in_progress_tasks']}")
        print(f"‚úÖ √á√∂z√ºmlenen Hatalar: {stats['resolved_errors']}")
        print(f"üî¥ Aktif Hatalar: {stats['active_errors']}")
        print(f"‚è±Ô∏è Session Uptime: {uptime}")

    def bulk_complete(self, task_ids):
        """Birden fazla g√∂revi toplu tamamla"""
        completed = []
        for task_id in task_ids:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            current_time = datetime.datetime.now().isoformat()

            cursor.execute(
                """
                UPDATE tasks 
                SET status = 'completed', 
                    updated_at = ?
                WHERE id = ? OR title LIKE ?
            """,
                (current_time, task_id, f"%{task_id}%"),
            )

            if cursor.rowcount > 0:
                completed.append(task_id)

            conn.commit()
            conn.close()

        if completed:
            print(f"‚úÖ {len(completed)} g√∂rev tamamlandƒ±:")
            for task_id in completed:
                print(f"  - {task_id}")
        else:
            print("‚ùå Hi√ß g√∂rev bulunamadƒ±.")

    def bulk_resolve(self, error_ids):
        """Birden fazla hatayƒ± toplu √ß√∂z√ºmle"""
        resolved = []
        for error_id in error_ids:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            current_time = datetime.datetime.now().isoformat()

            cursor.execute(
                """
                UPDATE errors 
                SET status = 'resolved', 
                    updated_at = ?
                WHERE id = ? OR title LIKE ?
            """,
                (current_time, error_id, f"%{error_id}%"),
            )

            if cursor.rowcount > 0:
                resolved.append(error_id)

            conn.commit()
            conn.close()

        if resolved:
            print(f"‚úÖ {len(resolved)} hata √ß√∂z√ºld√º:")
            for error_id in resolved:
                print(f"  - {error_id}")
        else:
            print("‚ùå Hi√ß hata bulunamadƒ±.")

    def help(self):
        """Yardƒ±m men√ºs√º"""
        print("üîß QUICK CONSOLE - KOMUTLAR")
        print("=" * 50)
        print("üìã G√ñREV Y√ñNETƒ∞Mƒ∞:")
        print("  tasks                    - G√∂revleri listele")
        print("  tasks-pending            - Bekleyen g√∂revleri listele")
        print("  tasks-completed          - Tamamlanan g√∂revleri listele")
        print("  complete-task <id>       - G√∂revi tamamla")
        print("  add-task <title>         - Yeni g√∂rev ekle")
        print("  bulk-complete <id1,id2>  - Birden fazla g√∂rev tamamla")
        print("")
        print("üî¥ HATA Y√ñNETƒ∞Mƒ∞:")
        print("  errors                   - Hatalarƒ± listele")
        print("  errors-active            - Aktif hatalarƒ± listele")
        print("  errors-resolved          - √á√∂z√ºmlenen hatalarƒ± listele")
        print("  resolve-error <id>       - Hatayƒ± √ß√∂z√ºmle")
        print("  add-error <title>        - Yeni hata ekle")
        print("  bulk-resolve <id1,id2>   - Birden fazla hata √ß√∂z√ºmle")
        print("")
        print("üìä Sƒ∞STEM:")
        print("  status                   - Sistem durumu")
        print("  memory                   - Hafƒ±za bilgileri")
        print("  context                  - Context bilgileri")
        print("  help                     - Bu yardƒ±m men√ºs√º")
        print("")
        print("üìÑ DOK√úMAN ƒ∞ZLEME:")
        print("  document-tracking        - Dok√ºman izleme komutlarƒ±")
        print("  check-unprocessed <dir>  - ƒ∞≈ülenmemi≈ü dok√ºmanlarƒ± kontrol et")
        print("  list-processed-docs <n>  - ƒ∞≈ülenmi≈ü dok√ºmanlarƒ± listele")
        print("  get-doc-stats            - Dok√ºman istatistikleri")
        print("  mark-processed <file>    - Dok√ºmanƒ± i≈ülenmi≈ü olarak i≈üaretle")
        print("  check-processed <file>   - Dok√ºman i≈ülenme durumunu kontrol et")

    def run_command(self, command, args=None):
        """Komut √ßalƒ±≈ütƒ±r"""
        self.command_history.append(command)

        if command == "help":
            self.help()
        elif command == "status":
            self.status()
        elif command == "tasks":
            self.list_tasks()
        elif command == "tasks-pending":
            self.list_tasks(status="pending")
        elif command == "tasks-completed":
            self.list_tasks(status="completed")
        elif command == "errors":
            self.list_errors()
        elif command == "errors-active":
            self.list_errors(status="active")
        elif command == "errors-resolved":
            self.list_errors(status="resolved")
        elif command.startswith("complete-task"):
            if len(command.split()) > 1:
                task_search = command.split()[1]
                solution = (
                    " ".join(command.split()[2:]) if len(command.split()) > 2 else None
                )
                self.complete_task(task_search, solution)
            else:
                print("‚ùå Kullanƒ±m: complete-task <task_id> [solution]")
        elif command.startswith("resolve-error"):
            if len(command.split()) > 1:
                error_search = command.split()[1]
                solution = (
                    " ".join(command.split()[2:]) if len(command.split()) > 2 else None
                )
                self.resolve_error(error_search, solution)
            else:
                print("‚ùå Kullanƒ±m: resolve-error <error_id> [solution]")
        elif command.startswith("add-task"):
            if len(command.split()) > 1:
                title = " ".join(command.split()[1:])
                self.add_task(title)
            else:
                print("‚ùå Kullanƒ±m: add-task <title>")
        elif command.startswith("add-error"):
            if len(command.split()) > 1:
                title = " ".join(command.split()[1:])
                self.add_error(title)
            else:
                print("‚ùå Kullanƒ±m: add-error <title>")
        elif command.startswith("bulk-complete"):
            if len(command.split()) > 1:
                task_ids = command.split()[1].split(",")
                self.bulk_complete(task_ids)
            else:
                print("‚ùå Kullanƒ±m: bulk-complete <id1,id2,id3>")
        elif command.startswith("bulk-resolve"):
            if len(command.split()) > 1:
                error_ids = command.split()[1].split(",")
                self.bulk_resolve(error_ids)
            else:
                print("‚ùå Kullanƒ±m: bulk-resolve <id1,id2,id3>")
        elif command == "memory":
            print("üß† HAFIZA KURALLARI:")
            print("=" * 40)
            for key, value in self.memory_rules.items():
                print(f"  {key}: {value}")
        elif command == "context":
            print("üîç CONTEXT Bƒ∞LGƒ∞LERƒ∞:")
            print("=" * 40)
            print(f"  Database: {self.db_path}")
            print(f"  Session Start: {self.session_start}")
            print(f"  Commands Run: {len(self.command_history)}")
        elif command == "document-tracking":
            print("üìÑ DOK√úMAN ƒ∞ZLEME:")
            print("=" * 40)
            print("  1. ƒ∞≈ülenmemi≈ü Dok√ºmanlarƒ± Kontrol Et:")
            print("  check-unprocessed <dizin_yolu>")
            print("  2. ƒ∞≈ülenmi≈ü Dok√ºmanlarƒ± Listele:")
            print("  list-processed-docs <limit>")
            print("  3. Dok√ºman ƒ∞≈üleme Durumunu G√∂r√ºnt√ºle:")
            print("  get-doc-stats")
            print("  4. Dok√ºmanƒ± ƒ∞≈ülenmi≈ü Olarak ƒ∞≈üaretle:")
            print("  mark-processed <dosya_yolu> [i≈ülem_t√ºr√º]")
            print("  5. Dok√ºman ƒ∞≈üleme Durumunu Kontrol Et:")
            print("  check-processed <dosya_yolu>")
        elif command.startswith("check-unprocessed"):
            if len(command.split()) > 1:
                directory_path = " ".join(command.split()[1:])
                self.check_unprocessed_documents(directory_path)
            else:
                print("‚ùå Kullanƒ±m: check-unprocessed <dizin_yolu>")
        elif command.startswith("list-processed-docs"):
            limit = 10
            if len(command.split()) > 1:
                try:
                    limit = int(command.split()[1])
                except ValueError:
                    print("‚ùå Limit sayƒ± olmalƒ±")
                    return
            self.list_processed_documents(limit)
        elif command == "get-doc-stats":
            stats = self.get_document_stats()
            print("üìä DOK√úMAN ƒ∞STATƒ∞STƒ∞KLERƒ∞:")
            print("=" * 40)
            print(f"  üìÑ Toplam Dok√ºman: {stats['total_docs']}")

            if stats["total_size"] > 1024 * 1024:
                size_str = f"{stats['total_size'] / (1024*1024):.1f} MB"
            elif stats["total_size"] > 1024:
                size_str = f"{stats['total_size'] / 1024:.1f} KB"
            else:
                size_str = f"{stats['total_size']} B"

            print(f"  üìä Toplam Boyut: {size_str}")
            print(f"  üìã ƒ∞≈ülem T√ºrlerine G√∂re:")

            for type_stat in stats["by_type"]:
                total, processed, size, proc_type = type_stat
                print(f"    {proc_type}: {total} dok√ºman")
        elif command.startswith("mark-processed"):
            parts = command.split()
            if len(parts) > 1:
                file_path = " ".join(parts[1:2])
                processing_type = parts[2] if len(parts) > 2 else "indexed"
                notes = " ".join(parts[3:]) if len(parts) > 3 else None
                self.mark_document_processed(file_path, processing_type, notes)
            else:
                print("‚ùå Kullanƒ±m: mark-processed <dosya_yolu> [i≈ülem_t√ºr√º]")
        elif command.startswith("check-processed"):
            if len(command.split()) > 1:
                file_path = " ".join(command.split()[1:])
                is_processed = self.is_document_processed(file_path)
                if is_processed:
                    print(f"‚úÖ {file_path} - ƒ∞≈ülenmi≈ü")
                else:
                    print(f"‚ùå {file_path} - ƒ∞≈ülenmemi≈ü")
            else:
                print("‚ùå Kullanƒ±m: check-processed <dosya_yolu>")
        else:
            print(f"‚ùå Bilinmeyen komut: {command}")
            print("üí° 'help' komutunu kullanƒ±n.")


def main():
    if len(sys.argv) < 2:
        print("‚ùå Kullanƒ±m: python quick_console.py <komut>")
        print("üí° √ñrnek: python quick_console.py help")
        return

    console = QuickConsole()
    command = " ".join(sys.argv[1:])
    console.run_command(command)


if __name__ == "__main__":
    main()
